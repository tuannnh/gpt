{"version":3,"file":"5525.606425857269510151e5.js","mappings":"ijBAoFA,MAAMA,EAKJC,YACSC,EACCC,EACAC,GACR,KAHOF,OAAAA,EAAc,KACbC,SAAAA,EAAsC,KACtCC,QAAAA,EAAgBC,EAAA,qBAPF,IAAIC,KAA4BD,EAAA,+BAEtB,IAAIC,IAOtC,CAGOC,UACP,CAEAC,OAAqB,QAAAC,EAAAC,UAAAC,OAAbC,EAAI,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,GAAAJ,UAAAI,GACVC,KAAKC,YAAY,CACfC,KAAM,OACNL,QAEJ,CAEAM,QAAQC,GACN,MAAM,cAAEC,EAAa,wBAAEC,GAA4BN,KAE7CO,GAAYC,EAAAA,EAAAA,GAAcH,GAC1BI,EAA0B,CAC9BP,KAAM,aACNK,eACGH,GAGCM,EAAe,CAAEH,aAGjBI,EAAwB,IAAIC,SAAQ,CAACC,EAASC,KAClDC,OAAOC,OAAON,EAAc,CAAEG,UAASC,UAAS,IAGlD,GAAqD,mBAA1CL,EAAQZ,KAAKY,EAAQZ,KAAKD,OAAS,GAAmB,CAC/Da,EAAQQ,cAAe,EAEvB,MAAMC,EAAWT,EAAQZ,KAAKsB,MAC9BT,EAAaQ,SAAWA,EACxBZ,EAAwBc,IAAIF,EAAUR,EACxC,CAeA,OAbAL,EAAce,IAAIb,EAAWG,GAC7BC,EACGU,OAAM,KAAe,IACrBC,SAAQ,KACPjB,EAAckB,OAAOhB,GAEjBG,EAAaQ,UACfZ,EAAwBiB,OAAOb,EAAaQ,SAC9C,IAGJlB,KAAKC,YAAYQ,GAEVE,CACT,CAEAa,eAAeC,GACbA,EAAiBC,YAAa,EAE9B,MAAM,UAAEnB,GAAcP,KAAKM,wBAAwBqB,IAAIF,IAAqB,CAAC,EACxElB,GAILP,KAAKC,YAAY,CACfC,KAAM,iBACNK,aAEJ,CAEAqB,UAAUC,GACR,MAAM,cAAExB,EAAa,QAAEhB,GAAYW,KACnC,GAAI6B,EAAKxC,UAAYA,EAOrB,GAHkB,WAAdwC,EAAK3B,MAAqBF,KAAKZ,UACjCY,KAAKZ,SAASyC,EAAKC,QAEH,mBAAdD,EAAK3B,KAA2B,CAClC,MAAMQ,EAAeL,EAAcsB,IAAIE,EAAKtB,WACxCG,IACEmB,EAAKE,MACPrB,EAAaI,OAAOe,EAAKE,OAEzBrB,EAAaG,QAAQgB,EAAKG,UAGhC,MAAO,GAAkB,mBAAdH,EAAK3B,KACOG,EAAcsB,IAAIE,EAAKtB,YAC9BW,cAAcW,EAAKI,mBAC5B,GAAkB,mBAAdJ,EAAK3B,KACd,MAAM,IAAIgC,MAAML,EAAKE,OAAOI,QAEhC,CAEQlC,YAAY4B,GAClBA,EAAKxC,QAAUW,KAAKX,QAEpBW,KAAKb,OAAOc,YAAY4B,EAC1B,EAGK,SAASO,EACdC,EACAjD,EACAC,GAEA,MAAMiD,EAAY,IAAIrD,EAAkBoD,EAAQjD,EAAUC,GAE1D,SAASkD,EAAaC,GAA+B,IAA9B,KAAEX,GAA0BW,EACjDF,EAAUV,UAAUC,EACtB,CAQA,OANAQ,EAAOI,iBAAiB,UAAWF,GAEnCD,EAAU9C,QAAU,KAClB6C,EAAOK,oBAAoB,UAAWH,EAAc,EAG/CD,CACT,C,iBCrNe,SAASK,EAAc/C,EAAgBgD,GACpD,OAAOA,EAAQC,KAAKC,MAAMF,EAAQhD,GAAUA,CAC9C,C","sources":["webpack://telegram-t/./src/util/PostMessageConnector.ts","webpack://telegram-t/./src/util/cycleRestrict.ts"],"sourcesContent":["import generateIdFor from './generateIdFor';\n\nexport interface CancellableCallback {\n  (\n    ...args: any[]\n  ): void;\n\n  isCanceled?: boolean;\n  acceptsBuffer?: boolean;\n}\n\ntype InitData = {\n  channel?: string;\n  type: 'init';\n  messageId?: string;\n  name: 'init';\n  args: any;\n};\n\ntype CallMethodData = {\n  channel?: string;\n  type: 'callMethod';\n  messageId?: string;\n  name: string;\n  args: any;\n  withCallback?: boolean;\n};\n\nexport type OriginMessageData = InitData | CallMethodData | {\n  channel?: string;\n  type: 'cancelProgress';\n  messageId: string;\n};\n\nexport interface OriginMessageEvent {\n  data: OriginMessageData;\n}\n\nexport type ApiUpdate =\n  { type: string }\n  & any;\n\nexport type WorkerMessageData = {\n  channel?: string;\n  type: 'update';\n  update: ApiUpdate;\n} | {\n  channel?: string;\n  type: 'methodResponse';\n  messageId: string;\n  response?: any;\n  error?: { message: string };\n} | {\n  channel?: string;\n  type: 'methodCallback';\n  messageId: string;\n  callbackArgs: any[];\n} | {\n  channel?: string;\n  type: 'unhandledError';\n  error?: { message: string };\n};\n\nexport interface WorkerMessageEvent {\n  data: WorkerMessageData;\n}\n\ninterface RequestStates {\n  messageId: string;\n  resolve: Function;\n  reject: Function;\n  callback: AnyToVoidFunction;\n}\n\ntype InputRequestTypes = Record<string, AnyFunction>;\n\ntype Values<T> = T[keyof T];\nexport type RequestTypes<T extends InputRequestTypes> = Values<{\n  [Name in keyof (T)]: {\n    name: Name & string;\n    args: Parameters<T[Name]>;\n  }\n}>;\n\nclass ConnectorClass<T extends InputRequestTypes> {\n  private requestStates = new Map<string, RequestStates>();\n\n  private requestStatesByCallback = new Map<AnyToVoidFunction, RequestStates>();\n\n  constructor(\n    public target: Worker,\n    private onUpdate?: (update: ApiUpdate) => void,\n    private channel?: string,\n  ) {\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public destroy() {\n  }\n\n  init(...args: any[]) {\n    this.postMessage({\n      type: 'init',\n      args,\n    });\n  }\n\n  request(messageData: RequestTypes<T>) {\n    const { requestStates, requestStatesByCallback } = this;\n\n    const messageId = generateIdFor(requestStates);\n    const payload: CallMethodData = {\n      type: 'callMethod',\n      messageId,\n      ...messageData,\n    };\n\n    const requestState = { messageId } as RequestStates;\n\n    // Re-wrap type because of `postMessage`\n    const promise: Promise<any> = new Promise((resolve, reject) => {\n      Object.assign(requestState, { resolve, reject });\n    });\n\n    if (typeof payload.args[payload.args.length - 1] === 'function') {\n      payload.withCallback = true;\n\n      const callback = payload.args.pop() as AnyToVoidFunction;\n      requestState.callback = callback;\n      requestStatesByCallback.set(callback, requestState);\n    }\n\n    requestStates.set(messageId, requestState);\n    promise\n      .catch(() => undefined)\n      .finally(() => {\n        requestStates.delete(messageId);\n\n        if (requestState.callback) {\n          requestStatesByCallback.delete(requestState.callback);\n        }\n      });\n\n    this.postMessage(payload);\n\n    return promise;\n  }\n\n  cancelCallback(progressCallback: CancellableCallback) {\n    progressCallback.isCanceled = true;\n\n    const { messageId } = this.requestStatesByCallback.get(progressCallback) || {};\n    if (!messageId) {\n      return;\n    }\n\n    this.postMessage({\n      type: 'cancelProgress',\n      messageId,\n    });\n  }\n\n  onMessage(data: WorkerMessageData) {\n    const { requestStates, channel } = this;\n    if (data.channel !== channel) {\n      return;\n    }\n\n    if (data.type === 'update' && this.onUpdate) {\n      this.onUpdate(data.update);\n    }\n    if (data.type === 'methodResponse') {\n      const requestState = requestStates.get(data.messageId);\n      if (requestState) {\n        if (data.error) {\n          requestState.reject(data.error);\n        } else {\n          requestState.resolve(data.response);\n        }\n      }\n    } else if (data.type === 'methodCallback') {\n      const requestState = requestStates.get(data.messageId);\n      requestState?.callback?.(...data.callbackArgs);\n    } else if (data.type === 'unhandledError') {\n      throw new Error(data.error?.message);\n    }\n  }\n\n  private postMessage(data: AnyLiteral) {\n    data.channel = this.channel;\n\n    this.target.postMessage(data);\n  }\n}\n\nexport function createConnector<T extends InputRequestTypes>(\n  worker: Worker,\n  onUpdate?: (update: ApiUpdate) => void,\n  channel?: string,\n) {\n  const connector = new ConnectorClass<T>(worker, onUpdate, channel);\n\n  function handleMessage({ data }: WorkerMessageEvent) {\n    connector.onMessage(data);\n  }\n\n  worker.addEventListener('message', handleMessage);\n\n  connector.destroy = () => {\n    worker.removeEventListener('message', handleMessage);\n  };\n\n  return connector;\n}\n\nexport type Connector<T extends InputRequestTypes = InputRequestTypes> = ReturnType<typeof createConnector<T>>;\n","export default function cycleRestrict(length: number, index: number) {\n  return index - Math.floor(index / length) * length;\n}\n"],"names":["ConnectorClass","constructor","target","onUpdate","channel","_defineProperty","Map","destroy","init","_len","arguments","length","args","Array","_key","this","postMessage","type","request","messageData","requestStates","requestStatesByCallback","messageId","generateIdFor","payload","requestState","promise","Promise","resolve","reject","Object","assign","withCallback","callback","pop","set","catch","finally","delete","cancelCallback","progressCallback","isCanceled","get","onMessage","data","update","error","response","callbackArgs","Error","message","createConnector","worker","connector","handleMessage","_ref","addEventListener","removeEventListener","cycleRestrict","index","Math","floor"],"sourceRoot":""}